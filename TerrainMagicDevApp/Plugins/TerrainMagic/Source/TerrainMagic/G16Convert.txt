const FName MapBoxTexturePath = "/Game/terrain1.terrain1";
	UTexture2D* MapBoxTexture = Cast<UTexture2D>(StaticLoadObject(UTexture2D::StaticClass(), nullptr, *MapBoxTexturePath.ToString()));
	SourceTexture = MapBoxTexture;
	SourceTexture->CompressionSettings = TextureCompressionSettings::TC_VectorDisplacementmap;
	SourceTexture->MipGenSettings = TextureMipGenSettings::TMGS_NoMipmaps;
	SourceTexture->SRGB = false;
	SourceTexture->Filter = TF_Bilinear;
	SourceTexture->UpdateResource();

	const int32 TextureWidth = SourceTexture->GetSizeX();
	G16Texture = UG16Texture::MakeSerializable(TextureWidth, "Hello Texture");
	Texture = G16Texture->GetTexture();

	const FTexture2DMipMap& SourceTextureMip = SourceTexture->PlatformData->Mips[0];
	const FColor* SourceTextureData = static_cast<const FColor*>(SourceTextureMip.BulkData.LockReadOnly());
	const int32 Max16BitValue = FMath::Pow(2, 16) - 1;

	TArray<float> HeightArray;
	HeightArray.SetNumZeroed(SourceTexture->GetSizeX() * SourceTexture->GetSizeY());

	for (int32 X = 0; X<SourceTexture->GetSizeX(); X++)
		{
		for (int32 Y=0; Y <SourceTexture->GetSizeY(); Y++)
		{
			const int32 Index = Y * SourceTexture->GetSizeX() + X;
			const FColor Pixel = SourceTextureData[Index];
			const float Height = -10000 + ((Pixel.R * 256 * 256 + Pixel.G * 256 + Pixel.B) * 0.1);
			HeightArray[Index] = Height;
		}
	}

	const float MinHeight = FMath::Min(HeightArray);
	const float MaxHeight = FMath::Max(HeightArray);
	const float HeightRange = MaxHeight - MinHeight;
	const float HeightRangeRatio = Max16BitValue / HeightRange;
	
	for (int32 X = 0; X<SourceTexture->GetSizeX(); X++)
	{
		for (int32 Y=0; Y <SourceTexture->GetSizeY(); Y++)
		{
			const int32 Index = Y * SourceTexture->GetSizeX() + X;
			const uint16 G16Height = (HeightArray[Index] - MinHeight) * HeightRangeRatio;
			if (Y == 200)
			{
				UE_LOG(LogTemp, Warning, TEXT("G16 Height: %d"), G16Height)
			}
			G16Texture->WritePixel(X, Y, G16Height);
		}
	}
	
	 SourceTextureMip.BulkData.Unlock();
	 G16Texture->UpdateTexture();